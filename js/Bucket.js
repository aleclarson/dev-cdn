// Generated by CoffeeScript 2.2.4
var Bucket, EventStream, app, crypto, defaultIgnore, fs, hasKeys, huey, loadAssets, log, noop, past, path, setProto, sha256, wch;

EventStream = require('./EventStream');

hasKeys = require('hasKeys');

crypto = require('crypto');

huey = require('huey');

noop = require('noop');

path = require('path');

app = require('./app');

log = require('./log');

wch = require('wch');

fs = require('./fs');

setProto = Object.setPrototypeOf;

defaultIgnore = [
  '.*.sw[a-z]',
  '*~', // vim temporary files
  '.DS_Store' // macOS Finder metadata
];

// Buckets are local caches for project assets.
Bucket = class Bucket {
  constructor(opts) {
    this.name = opts.name;
    this.root = opts.root;
    this.ignore = opts.ignore || defaultIgnore;
    this.assets = this._loadAssets();
    this.events = new EventStream;
    this.projects = Object.create(null);
    this;
  }

  has(name) {
    return this.assets[name] != null;
  }

  get(name) {
    var value;
    if (value = this.assets[name]) {
      if (value === true) {
        value = name;
      }
      return fs.read(this._dest(value));
    }
  }

  patch(values) {
    var event, name, prev, value;
    for (name in values) {
      value = values[name];
      if (value === null) {
        this.delete(name);
        continue;
      }
      prev = this.assets[name];
      this.assets[name] = value;
      if (prev) {
        if (prev === true) {
          prev = name;
        }
        prev = this._dest(prev);
        if (value === true) {
          value = name;
        }
        fs.rename(prev, this._dest(value));
      }
      event = prev ? 'change' : 'add';
      this.events.emit(event, {name, value});
    }
    this.save();
  }

  put(name) {
    var dest, event, exists, ext, file, src, value;
    src = path.join(this.root, name);
    file = fs.readFile(src, null);
    value = this.assets[name];
    exists = value != null;
    // Assets set to true have no content hash.
    if (value === true) {
      dest = name;
    } else {
      ext = path.extname(name);
      dest = name.slice(0, 1 - ext.length) + sha256(file, 10) + ext;
      if (dest === value) {
        return;
      }
      this.assets[name] = value = dest;
      this.save();
    }
    dest = this._dest(dest);
    if (!exists) {
      fs.writeDir(path.dirname(dest));
    }
    fs.writeFile(dest, file);
    event = exists ? 'change' : 'add';
    if (!this.loading) {
      log.pale_green(`Asset ${past(event)}:`, huey.gray(`/b/${this.name}/`) + name);
    }
    this.events.emit(event, {name, value});
  }

  delete(name) {
    var cwd, dest;
    if (dest = this.assets[name]) {
      delete this.assets[name];
      this.save();
      if (dest === true) {
        dest = name;
      }
      dest = this._dest(dest);
      // Jump to the bucket directory.
      cwd = process.cwd();
      process.chdir(fs.bucketDir);
      // Remove the file, and its directory (if empty)
      fs.removeFile(dest);
      try {
        fs.removeDir(path.dirname(dest), false);
      } catch (error) {}
      // Return to the working directory.
      process.chdir(cwd);
      if (!this.loading) {
        log.pale_pink('Asset deleted:', huey.gray(`/b/${this.name}/`) + name);
      }
      this.events.emit('delete', {name});
    }
  }

  query(opts = {}) {
    opts.exclude = this.ignore;
    return wch.query(this.root, opts);
  }

  save() {
    return fs.writeJson(this._dest('assets.json'), this.assets);
  }

  drop(root) {
    var cwd;
    if (arguments.length) {
      delete this.projects[root];
      if (hasKeys(this.projects)) {
        return false;
      }
    } else {
      this.projects = Object.create(null);
    }
    if (log.verbose) {
      log.pale_pink('Dropping bucket:', this.name);
    }
    this.events.unpipe();
    this.watcher.destroy();
    // Jump to the bucket directory.
    cwd = process.cwd();
    process.chdir(fs.bucketDir);
    fs.removeDir(this._dest());
    // Return to the working directory.
    process.chdir(cwd);
    return true;
  }

  _dest(name = '') {
    return path.join(fs.bucketDir, this.name, name);
  }

  _resolve(...args) {
    var name;
    name = path.relative(this.root, path.join(...args));
    if (name[0] !== '.') {
      return name;
    } else {
      return null;
    }
  }

  _loadAssets() {
    var assets, bucketPath, jsonPath, query;
    bucketPath = this._dest();
    if (fs.isDir(bucketPath)) {
      log.pale_yellow('Loading bucket:', this.name);
    } else {
      log.pale_green('New bucket:', this.name, '->', this.root);
      fs.writeDir(bucketPath);
    }
    jsonPath = this._dest('assets.json');
    if (assets = loadAssets(jsonPath)) {
      query = this.query({
        since: fs.stat(jsonPath).mtime
      });
    } else {
      assets = Object.create(null);
      assets['assets.json'] = true;
      query = this.query();
    }
    query.then((files) => {
      var root;
      this.save = noop;
      this.loading = true;
      ({root} = files);
      files.forEach((file) => {
        var name;
        name = this._resolve(root, file.name);
        if (file.exists) {
          return this.put(name);
        } else {
          return this.delete(name);
        }
      });
      this.loading = false;
      // Save even if no changes were made.
      delete this.save;
      this.save();
      return this.watcher = wch.stream(root).on('data', (file) => {
        var name;
        if (name = this._resolve(file.path)) {
          if (file.exists) {
            return this.put(name);
          } else {
            return this.delete(name);
          }
        }
      });
    }).catch(function(err) {
      return console.error(err.stack);
    });
    return assets;
  }

};

module.exports = Bucket;

past = function(str) {
  return str.replace(/e?$/, 'ed');
};

loadAssets = function(jsonPath) {
  var assets;
  if (fs.isFile(jsonPath)) {
    assets = fs.readJson(jsonPath);
    setProto(assets, null);
    return assets;
  }
};

sha256 = function(buffer, length) {
  var hash;
  hash = crypto.createHash('sha256').update(buffer).digest('hex');
  if (typeof length === 'number') {
    return hash.slice(0, length);
  } else {
    return hash;
  }
};

//# sourceMappingURL=Bucket.js.map
