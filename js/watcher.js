// Generated by CoffeeScript 2.2.4
var app, fields, fs, ignored, log, path, started, streams, watchPackage, wch;

path = require('path');

app = require('./app');

log = require('./log');

wch = require('wch');

fs = require('./fs');

// TODO: Invalidate package files when the package becomes unused
started = false;

streams = new Map;

exports.start = function() {
  var bundler;
  if (!started) {
    started = true;
    ({bundler} = app);
    bundler.on('package:used', this.watch);
    bundler.on('package:unused', this.unwatch);
  }
};

exports.watch = function(pack) {
  if (!streams.has(pack)) {
    return streams.set(pack, watchPackage(pack));
  }
};

exports.unwatch = function(pack) {
  var stream;
  if (stream = streams.get(pack)) {
    streams.delete(pack);
    return stream.destroy();
  }
};

exports.stop = function() {
  if (log.verbose) {
    log.pale_pink('Closing watch streams...');
  }
  started = false;
  streams.forEach(function(s) {
    return s.destroy();
  });
};


// Helpers

fields = ['name', 'type', 'new', 'exists'];

ignored = [
  '**/node_modules/**', // dependencies
  '.*.sw[a-z]',
  '*~', // vim temporary files
  '.DS_Store' // macOS Finder metadata
];

// TODO: Update `package.dirs` when directories are added/removed
// TODO: Clear module resolutions for removed dependencies
watchPackage = function(pack) {
  var root;
  root = fs.readLinks(pack.path);
  log.pale_green('Watching package:', root);
  return wch.stream(root, {
    fields,
    exclude: ignored
  }).on('data', function(file) {
    var bundler, ext;
    if (file.name === 'package.json') {
      return pack._readMeta();
    }
    ({bundler} = pack);
    if (file.new) {
      ext = path.extname(file.name);
      return bundler.addFile(file.path, ext, pack);
    }
    if (file.exists) {
      bundler.reloadFile(file.path);
    } else {
      bundler.deleteFile(file.path);
    }
  });
};

//   const bundles = project
//     .filterBundles(bundle => bundle.hasModule(file))

//   if (patch.event == 'change') {
//     bundles.forEach(bundle => {
//       bundle.reloadModule(patch.file)
//     })
//   } else if (patch.event == 'unlink') {
//     bundles.forEach(bundle => {
//       bundle.deleteModule(patch.file)
//     })
//   } else {
//     const error = 'Expected `body.event` to equal "change" or "unlink"'
//     return {status: 400, error}
//   }

//   return {status: 200}
// }

//# sourceMappingURL=watcher.js.map
