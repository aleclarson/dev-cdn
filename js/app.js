// Generated by CoffeeScript 2.2.4
var App, Bundler, Project, SOCK_PATH, crawlProject, fillRefs, fs, getElapsed, globRegex, huey, log, noop, onError, os, path, slush, steal;

globRegex = require('glob-regex');

({Bundler} = require('cara'));

slush = require('slush');

steal = require('steal');

huey = require('huey');

noop = require('noop');

path = require('path');

log = require('./log');

fs = require('./fs');

os = require('os');

SOCK_PATH = os.homedir() + '/.cara/cdn.sock';

App = class App {
  start() {
    this.server = slush({
      sock: SOCK_PATH
    });
    this.bundler = new Bundler;
    this.buckets = {};
    this.projects = {};
    this.bundler.on('warn', function(msg) {
      return log.yellow('warn:', msg);
    });
    this.bundler.on('error', onError);
    this.server.on('error', onError);
    return this.server;
  }

  stop() {
    if (log.verbose) {
      log.pale_pink('Closing asset server...');
    }
    fs.removeFile(SOCK_PATH, false);
    this.server.close();
    this.server = null;
    this.bundler = null;
    this.buckets = null;
    this.projects = null;
  }

  read(req, res) {
    var project, ref, root, val;
    if (req.project) {
      return project.read(req, res);
    }
    ref = req.bucket.projects;
    for (root in ref) {
      project = ref[root];
      val = project.read(req, res);
      if (val !== false) {
        return val;
      }
    }
  }

  add(root) {
    var bundleNames, bundles, config, project;
    if (this.projects.hasOwnProperty(root)) {
      throw Error('Already loaded: ' + root);
    }
    if (log.verbose) {
      log.pale_yellow('Loading project:', root);
    }
    // TODO: Watch project file for changes.
    config = Project.load(root);
    project = this.bundler.project({
      root: config.root,
      fileTypes: config.exts
    });
    // Remember which buckets we are using.
    project.buckets = config.buckets;
    config.buckets.forEach(function(bucket) {
      return bucket.projects[root] = project;
    });
    // Populate the bundler with files.
    crawlProject(project);
    // Setup the bundle readers.
    bundleNames = Object.keys(config.bundles);
    bundles = bundleNames.map(function(bundleName) {
      var bundleMain, opts;
      opts = config.bundles[bundleName];
      if (opts.onStop == null) {
        opts.onStop = noop;
      }
      bundleName = globRegex(bundleName);
      bundleMain = steal(opts, 'main');
      return function(req, res) {
        var match;
        if (!(match = bundleName.exec(req.file))) {
          return false;
        }
        return project.bundle({
          dev: /^(1||true)$/.test(req.query.dev),
          main: fillRefs(bundleMain, match),
          platform: req.query.platform || 'web'
        }).then(async function(bundle) {
          var cached, code, elapsed, mainPath, started;
          started = Date.now();
          cached = bundle.isCached;
          code = (await bundle.read(opts));
          if (bundle.error) {
            res.status(400);
            res.send(bundle.error);
            return true;
          }
          if (code && !cached) {
            elapsed = huey.cyan(getElapsed(started));
            mainPath = huey.pale_green('~/' + bundle._main.name);
            log(`ðŸ“¦ Bundled ${mainPath} in ${elapsed}`);
          }
          return code;
        });
      };
    });
    project.read = async function(req, res) {
      var err, i, len, read, val;
      try {
        for (i = 0, len = bundles.length; i < len; i++) {
          read = bundles[i];
          val = (await read(req, res));
          if (val !== false) {
            return val;
          }
        }
      } catch (error) {
        err = error;
        if (err.code === 'NO_MAIN_MODULE') {
          res.status(400);
          res.send({
            error: err.message,
            code: err.code
          });
          return true;
        }
        throw err;
      }
    };
    this.projects[root] = project;
    return project;
  }

  // TODO: Properly unload the compiler for each bundle.
  remove(root) {
    var buckets;
    if (this.projects.hasOwnProperty(root)) {
      if (log.verbose) {
        log.pale_pink('Unloading project:', root);
      }
      // Remove unused buckets.
      ({buckets} = this.projects[root]);
      if (buckets != null) {
        buckets.forEach((bucket) => {
          if (bucket.drop(root)) {
            return delete this.buckets[bucket.name];
          }
        });
      }
      // Remove the project.
      return delete this.projects[root];
    }
  }

};

module.exports = new App;

// app -> Project -> app
Project = require('./Project');

// Replaces '$1' with `arr[1]` etc.
fillRefs = function(str, arr) {
  if (str) {
    return str.replace(/\$[0-9]+/g, function(str) {
      return arr[str.slice(1)];
    });
  } else {
    return '';
  }
};

getElapsed = function(started) {
  var elapsed;
  elapsed = Date.now() - started;
  if (elapsed < 1000) {
    return elapsed + 'ms';
  } else {
    return (elapsed / 1000).toFixed(3) + 's';
  }
};

// TODO: Use watchman for crawling.
crawlProject = function(project) {
  var elapsed, name, started;
  started = Date.now();
  project.crawl();
  elapsed = huey.cyan(getElapsed(started));
  name = huey.pale_green(project.root.name);
  log(`âœ¨ Crawled ${name} in ${elapsed}`);
};

onError = function(err) {
  if (process.env.VERBOSE) {
    return log(err.stack);
  } else {
    return log.red(err.name + ':', err.message);
  }
};

//# sourceMappingURL=app.js.map
